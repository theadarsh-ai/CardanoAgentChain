# ============================================================================
# STEP-BY-STEP CARDANO DEFI API INTEGRATION FOR YIELDMAXIMIZER
# Complete implementation guide with all major protocols
# ============================================================================

# ============================================================================
# STEP 1: ENVIRONMENT SETUP
# ============================================================================

"""
Install required packages:
pip install pycardano requests python-dotenv numpy pandas
pip install web3 aiohttp
"""

import os
import requests
import json
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime
import asyncio
import aiohttp
from dotenv import load_dotenv

load_dotenv()

# Configuration
CARDANO_NETWORK = "mainnet"  # or "testnet"
BASE_BLOCKFROST_URL = "https://cardano-mainnet.blockfrost.io/api/v0"
BLOCKFROST_API_KEY = os.getenv("BLOCKFROST_API_KEY")  # Get from blockfrost.io

# Headers for API requests
HEADERS = {
    "Project_id": BLOCKFROST_API_KEY,
    "Content-Type": "application/json"
}

# ============================================================================
# STEP 2: DATA MODELS
# ============================================================================

@dataclass
class ProtocolMetrics:
    """Standard format for all protocol data"""
    protocol_name: str
    tvl: float
    apy: float
    pool_id: str
    token_pair: Tuple[str, str]
    risk_score: float  # 1-10
    last_updated: datetime
    url: str
    min_deposit: float = 0.0

@dataclass
class UserPortfolio:
    """User's investment portfolio"""
    wallet_address: str
    total_balance: float
    positions: Dict[str, float]  # protocol_name -> amount
    total_yield: float

# ============================================================================
# STEP 3: BLOCKFROST API - GET WALLET DATA
# ============================================================================

class BlockfrostClient:
    """Base client for querying Cardano blockchain via Blockfrost"""
    
    def __init__(self, api_key: str):
        self.api_key = api_key
        self.base_url = BASE_BLOCKFROST_URL
        self.headers = {"Project_id": api_key}
    
    def get_account_balance(self, wallet_address: str) -> Dict:
        """Get ADA and token balances for a wallet"""
        endpoint = f"{self.base_url}/accounts/{wallet_address}"
        response = requests.get(endpoint, headers=self.headers)
        
        if response.status_code == 200:
            data = response.json()
            return {
                "ada_balance": int(data["controlled_amount"]) / 1_000_000,  # Convert lovelace to ADA
                "tokens": data["amount"],  # Other tokens held
                "status": "success"
            }
        else:
            return {"status": "error", "message": response.text}
    
    def get_account_utxos(self, wallet_address: str) -> List[Dict]:
        """Get all UTxOs (coins) held by wallet - crucial for Cardano"""
        endpoint = f"{self.base_url}/accounts/{wallet_address}/utxos"
        response = requests.get(endpoint, headers=self.headers)
        
        if response.status_code == 200:
            return response.json()
        else:
            return []
    
    def get_latest_block(self) -> Dict:
        """Get current block info"""
        endpoint = f"{self.base_url}/blocks/latest"
        response = requests.get(endpoint, headers=self.headers)
        return response.json() if response.status_code == 200 else {}

# Usage example:
# blockfrost = BlockfrostClient(BLOCKFROST_API_KEY)
# balance = blockfrost.get_account_balance("addr1q...")
# print(f"ADA Balance: {balance['ada_balance']}")

# ============================================================================
# STEP 4: MINSWAP INTEGRATION
# ============================================================================

class MinswapAPI:
    """Integration with Minswap DEX for liquidity pools and farming"""
    
    def __init__(self):
        self.base_url = "https://api.minswap.io/v1"
        self.pool_endpoint = f"{self.base_url}/pools"
        self.farm_endpoint = f"{self.base_url}/farms"
    
    def get_all_pools(self) -> List[Dict]:
        """Fetch all liquidity pools from Minswap"""
        try:
            response = requests.get(self.pool_endpoint, timeout=10)
            response.raise_for_status()
            return response.json().get("pools", [])
        except Exception as e:
            print(f"Error fetching Minswap pools: {e}")
            return []
    
    def get_top_pools_by_tvl(self, limit: int = 10) -> List[ProtocolMetrics]:
        """Get top pools sorted by TVL"""
        pools = self.get_all_pools()
        
        metrics = []
        for pool in sorted(pools, key=lambda x: float(x.get("tvl", 0)), reverse=True)[:limit]:
            try:
                tvl = float(pool.get("tvl", 0))
                apy = float(pool.get("apy", {}).get("total", 0))
                
                metric = ProtocolMetrics(
                    protocol_name="Minswap",
                    tvl=tvl,
                    apy=apy,
                    pool_id=pool.get("id"),
                    token_pair=(pool.get("coin_a", {}).get("name"), 
                               pool.get("coin_b", {}).get("name")),
                    risk_score=3.0,  # Minswap is relatively safe
                    last_updated=datetime.now(),
                    url=f"https://minswap.org/farm/{pool.get('id')}",
                    min_deposit=10.0  # Min 10 ADA
                )
                metrics.append(metric)
            except Exception as e:
                print(f"Error parsing pool: {e}")
                continue
        
        return metrics
    
    def get_pool_by_id(self, pool_id: str) -> Optional[Dict]:
        """Get specific pool details"""
        endpoint = f"{self.pool_endpoint}/{pool_id}"
        try:
            response = requests.get(endpoint, timeout=10)
            return response.json() if response.status_code == 200 else None
        except Exception as e:
            print(f"Error fetching pool {pool_id}: {e}")
            return None
    
    def get_farms(self) -> List[Dict]:
        """Fetch all yield farming opportunities"""
        try:
            response = requests.get(self.farm_endpoint, timeout=10)
            return response.json().get("farms", [])
        except Exception as e:
            print(f"Error fetching Minswap farms: {e}")
            return []

# ============================================================================
# STEP 5: LIQWID FINANCE INTEGRATION
# ============================================================================

class LiqwidAPI:
    """Integration with Liqwid lending protocol"""
    
    def __init__(self):
        self.base_url = "https://api.liqwid.finance"
        self.markets_endpoint = f"{self.base_url}/markets"
    
    def get_all_markets(self) -> List[Dict]:
        """Fetch all lending markets"""
        try:
            response = requests.get(self.markets_endpoint, timeout=10)
            return response.json().get("markets", [])
        except Exception as e:
            print(f"Error fetching Liqwid markets: {e}")
            return []
    
    def get_market_data(self, token_name: str) -> Optional[Dict]:
        """Get specific market data (e.g., "ADA", "USDC")"""
        markets = self.get_all_markets()
        
        for market in markets:
            if market.get("underlying_token", {}).get("name", "").upper() == token_name.upper():
                return {
                    "token": token_name,
                    "supply_apy": float(market.get("supply_apy", 0)),
                    "borrow_apy": float(market.get("borrow_apy", 0)),
                    "tvl": float(market.get("total_supply", 0)),
                    "utilization": float(market.get("utilization_rate", 0)),
                    "collateral_factor": float(market.get("collateral_factor", 0))
                }
        return None
    
    def calculate_lending_yield(self, amount: float, token: str, months: int = 12) -> float:
        """Calculate projected yield from lending"""
        market = self.get_market_data(token)
        if not market:
            return 0.0
        
        apy = market["supply_apy"] / 100
        monthly_rate = apy / 12
        future_value = amount * ((1 + monthly_rate) ** months)
        return future_value - amount

# ============================================================================
# STEP 6: GENIUS YIELD INTEGRATION
# ============================================================================

class GeniusYieldAPI:
    """Integration with Genius Yield (AI-powered optimizer)"""
    
    def __init__(self):
        self.base_url = "https://api.geniusyield.co"
        self.vaults_endpoint = f"{self.base_url}/smart-liquidity-vaults"
    
    def get_smart_vaults(self) -> List[Dict]:
        """Fetch all Genius Yield Smart Liquidity Vaults"""
        try:
            response = requests.get(self.vaults_endpoint, timeout=10)
            return response.json().get("vaults", [])
        except Exception as e:
            print(f"Error fetching Genius Yield vaults: {e}")
            return []
    
    def get_vault_performance(self, vault_id: str) -> Optional[Dict]:
        """Get performance metrics for specific vault"""
        endpoint = f"{self.vaults_endpoint}/{vault_id}/performance"
        try:
            response = requests.get(endpoint, timeout=10)
            if response.status_code == 200:
                data = response.json()
                return {
                    "vault_id": vault_id,
                    "apy_7d": float(data.get("apy_7d", 0)),
                    "apy_30d": float(data.get("apy_30d", 0)),
                    "tvl": float(data.get("tvl", 0)),
                    "profit_realized": float(data.get("profit_realized", 0))
                }
        except Exception as e:
            print(f"Error fetching vault performance: {e}")
        return None

# ============================================================================
# STEP 7: LENFI INTEGRATION
# ============================================================================

class LenfiAPI:
    """Integration with Lenfi lending protocol"""
    
    def __init__(self):
        self.base_url = "https://api.lenfi.io"
        self.pools_endpoint = f"{self.base_url}/pools"
    
    def get_all_pools(self) -> List[Dict]:
        """Fetch all lending pools"""
        try:
            response = requests.get(self.pools_endpoint, timeout=10)
            return response.json().get("pools", [])
        except Exception as e:
            print(f"Error fetching Lenfi pools: {e}")
            return []
    
    def get_pool_apy(self, pool_id: str) -> Optional[float]:
        """Get APY for specific pool"""
        pools = self.get_all_pools()
        for pool in pools:
            if pool.get("id") == pool_id:
                return float(pool.get("apy", 0))
        return None

# ============================================================================
# STEP 8: AGGREGATE ALL PROTOCOLS
# ============================================================================

class YieldAggregator:
    """Aggregates yield data from all protocols"""
    
    def __init__(self):
        self.minswap = MinswapAPI()
        self.liqwid = LiqwidAPI()
        self.genius = GeniusYieldAPI()
        self.lenfi = LenfiAPI()
        self.blockfrost = BlockfrostClient(BLOCKFROST_API_KEY)
    
    def get_all_opportunities(self) -> List[ProtocolMetrics]:
        """Fetch yield opportunities from all sources"""
        opportunities = []
        
        # Minswap pools
        print("[1/4] Fetching Minswap pools...")
        opportunities.extend(self.minswap.get_top_pools_by_tvl(5))
        
        # Liqwid lending
        print("[2/4] Fetching Liqwid markets...")
        for token in ["ADA", "USDC"]:
            market = self.liqwid.get_market_data(token)
            if market:
                metric = ProtocolMetrics(
                    protocol_name="Liqwid",
                    tvl=market["tvl"],
                    apy=market["supply_apy"],
                    pool_id=f"liqwid_{token}",
                    token_pair=(token, ""),
                    risk_score=2.5,  # Liqwid is very safe (lending)
                    last_updated=datetime.now(),
                    url=f"https://liqwid.finance/markets/{token}",
                    min_deposit=5.0
                )
                opportunities.append(metric)
        
        # Genius Yield vaults
        print("[3/4] Fetching Genius Yield vaults...")
        vaults = self.genius.get_smart_vaults()
        for vault in vaults[:5]:
            perf = self.genius.get_vault_performance(vault.get("id"))
            if perf:
                metric = ProtocolMetrics(
                    protocol_name="Genius Yield",
                    tvl=perf["tvl"],
                    apy=perf["apy_30d"],
                    pool_id=vault.get("id"),
                    token_pair=(vault.get("pool_pair", ("", ""))),
                    risk_score=2.0,  # AI-optimized, very safe
                    last_updated=datetime.now(),
                    url=f"https://app.geniusyield.co/vault/{vault.get('id')}",
                    min_deposit=20.0
                )
                opportunities.append(metric)
        
        # Lenfi pools
        print("[4/4] Fetching Lenfi pools...")
        lenfi_pools = self.lenfi.get_all_pools()
        for pool in lenfi_pools[:5]:
            metric = ProtocolMetrics(
                protocol_name="Lenfi",
                tvl=float(pool.get("tvl", 0)),
                apy=float(pool.get("apy", 0)),
                pool_id=pool.get("id"),
                token_pair=(pool.get("token_a"), pool.get("token_b")),
                risk_score=3.5,
                last_updated=datetime.now(),
                url=f"https://lenfi.io/pool/{pool.get('id')}",
                min_deposit=10.0
            )
            opportunities.append(metric)
        
        return opportunities
    
    def rank_by_yield(self, opportunities: List[ProtocolMetrics]) -> List[ProtocolMetrics]:
        """Sort opportunities by risk-adjusted yield"""
        return sorted(
            opportunities,
            key=lambda x: x.apy / (x.risk_score + 1),  # Higher yield, lower risk = better
            reverse=True
        )

# ============================================================================
# STEP 9: PORTFOLIO OPTIMIZATION
# ============================================================================

class PortfolioOptimizer:
    """Optimizes user portfolio across opportunities"""
    
    @staticmethod
    def calculate_optimal_allocation(
        total_funds: float,
        opportunities: List[ProtocolMetrics],
        max_single_protocol: float = 0.4,  # Max 40% in one protocol
        min_deposit: float = 5.0  # Minimum deposit per opportunity
    ) -> Dict[str, float]:
        """Calculate optimal allocation across opportunities"""
        
        # Filter by deposit requirements
        eligible = [opp for opp in opportunities if opp.min_deposit <= min_deposit]
        
        if not eligible:
            return {"fallback_stable": total_funds}
        
        # Calculate weights based on risk-adjusted yield
        weights = []
        for opp in eligible:
            weight = opp.apy / (opp.risk_score + 1)
            weights.append(weight)
        
        # Normalize weights
        total_weight = sum(weights)
        normalized = [w / total_weight for w in weights]
        
        # Apply max single protocol constraint
        allocation = {}
        remaining = total_funds
        
        for opp, weight in zip(eligible, normalized):
            amount = min(total_funds * weight, total_funds * max_single_protocol)
            allocation[f"{opp.protocol_name}_{opp.pool_id}"] = amount
            remaining -= amount
        
        return allocation
    
    @staticmethod
    def calculate_projected_yield(
        allocation: Dict[str, float],
        opportunities: List[ProtocolMetrics],
        months: int = 12
    ) -> Dict[str, float]:
        """Calculate projected returns for each position"""
        
        results = {}
        opp_map = {f"{o.protocol_name}_{o.pool_id}": o for o in opportunities}
        
        for position, amount in allocation.items():
            opp = opp_map.get(position)
            if opp:
                apy = opp.apy / 100
                future_value = amount * ((1 + apy / 12) ** months)
                yield_amount = future_value - amount
                results[position] = {
                    "initial": amount,
                    "final": future_value,
                    "yield": yield_amount,
                    "apy": opp.apy
                }
        
        return results

# ============================================================================
# STEP 10: MAIN ORCHESTRATION
# ============================================================================

async def main():
    """Main execution flow"""
    
    print("=" * 70)
    print("YIELDMAXIMIZER - CARDANO DEFI YIELD OPTIMIZER")
    print("=" * 70)
    
    # Initialize aggregator
    aggregator = YieldAggregator()
    optimizer = PortfolioOptimizer()
    
    # Step 1: Fetch all yield opportunities
    print("\n[STEP 1] Fetching yield opportunities from all protocols...")
    opportunities = aggregator.get_all_opportunities()
    
    # Step 2: Rank by risk-adjusted yield
    print("\n[STEP 2] Ranking opportunities by risk-adjusted yield...")
    ranked = aggregator.rank_by_yield(opportunities)
    
    print("\nTop 10 Opportunities:")
    print("-" * 70)
    for i, opp in enumerate(ranked[:10], 1):
        risk_adj_yield = opp.apy / (opp.risk_score + 1)
        print(f"{i}. {opp.protocol_name} - {opp.token_pair}")
        print(f"   APY: {opp.apy:.2f}% | TVL: ${opp.tvl:,.0f}")
        print(f"   Risk Score: {opp.risk_score}/10 | Risk-Adj Yield: {risk_adj_yield:.2f}%")
        print()
    
    # Step 3: Calculate optimal portfolio allocation
    print("\n[STEP 3] Calculating optimal portfolio allocation...")
    user_funds = 1000.0  # Example: 1000 ADA
    allocation = optimizer.calculate_optimal_allocation(user_funds, ranked)
    
    print(f"\nOptimal Allocation for {user_funds} ADA:")
    print("-" * 70)
    total_allocated = 0
    for protocol, amount in allocation.items():
        percentage = (amount / user_funds) * 100
        print(f"{protocol}: {amount:.2f} ADA ({percentage:.1f}%)")
        total_allocated += amount
    
    # Step 4: Project yields
    print("\n[STEP 4] Projecting 12-month yields...")
    projections = optimizer.calculate_projected_yield(allocation, ranked, months=12)
    
    total_yield = 0
    total_final = 0
    print("\nProjected Returns (12 months):")
    print("-" * 70)
    for position, metrics in projections.items():
        print(f"{position}:")
        print(f"  Initial: {metrics['initial']:.2f} ADA")
        print(f"  Final: {metrics['final']:.2f} ADA")
        print(f"  Yield: {metrics['yield']:.2f} ADA ({(metrics['yield']/metrics['initial']*100):.2f}%)")
        total_yield += metrics['yield']
        total_final += metrics['final']
    
    print("\n" + "=" * 70)
    print(f"SUMMARY:")
    print(f"Initial Investment: {user_funds:.2f} ADA")
    print(f"Projected Final: {total_final:.2f} ADA")
    print(f"Total Yield: {total_yield:.2f} ADA")
    print(f"Average APY: {(total_yield/user_funds*100):.2f}%")
    print("=" * 70)

# ============================================================================
# EXECUTION
# ============================================================================

if __name__ == "__main__":
    # For synchronous execution:
    # asyncio.run(main())
    
    # Or direct execution:
    aggregator = YieldAggregator()
    opportunities = aggregator.get_all_opportunities()
    ranked = aggregator.rank_by_yield(opportunities)
    
    print("\nâœ… Data aggregation complete!")
    print(f"Found {len(opportunities)} yield opportunities")